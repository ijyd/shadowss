package v1

import (
	"gofreezer/pkg/api/unversioned"
	"gofreezer/pkg/fields"
	"gofreezer/pkg/labels"
	"gofreezer/pkg/types"
	"time"
)

// Common string formats
// ---------------------
// Many fields in this API have formatting requirements.  The commonly used
// formats are defined here.
//
// C_IDENTIFIER:  This is a string that conforms to the definition of an "identifier"
//     in the C language.  This is captured by the following regex:
//         [A-Za-z_][A-Za-z0-9_]*
//     This defines the format, but not the length restriction, which should be
//     specified at the definition of any field of this type.
//
// DNS_LABEL:  This is a string, no more than 63 characters long, that conforms
//     to the definition of a "label" in RFCs 1035 and 1123.  This is captured
//     by the following regex:
//         [a-z0-9]([-a-z0-9]*[a-z0-9])?
//
// DNS_SUBDOMAIN:  This is a string, no more than 253 characters long, that conforms
//      to the definition of a "subdomain" in RFCs 1035 and 1123.  This is captured
//      by the following regex:
//         [a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*
//     or more simply:
//         DNS_LABEL(\.DNS_LABEL)*
//
// IANA_SVC_NAME: This is a string, no more than 15 characters long, that
//      conforms to the definition of IANA service name in RFC 6335.
//      It must contains at least one letter [a-z] and it must contains only [a-z0-9-].
//      Hypens ('-') cannot be leading or trailing character of the string
//      and cannot be adjacent to other hyphens.

// ObjectMeta is metadata that all persisted resources must have, which includes all objects
// users must create.
type ObjectMeta struct {
	// Name is unique within a namespace.  Name is required when creating resources, although
	// some resources may allow a client to request the generation of an appropriate name
	// automatically. Name is primarily intended for creation idempotence and configuration
	// definition.
	Name string `json:"name,omitempty"`

	// GenerateName indicates that the name should be made unique by the server prior to persisting
	// it. A non-empty value for the field indicates the name will be made unique (and the name
	// returned to the client will be different than the name passed). The value of this field will
	// be combined with a unique suffix on the server if the Name field has not been provided.
	// The provided value must be valid within the rules for Name, and may be truncated by the length
	// of the suffix required to make the value unique on the server.
	//
	// If this field is specified, and Name is not present, the server will NOT return a 409 if the
	// generated name exists - instead, it will either return 201 Created or 500 with Reason
	// ServerTimeout indicating a unique name could not be found in the time allotted, and the client
	// should retry (optionally after the time indicated in the Retry-After header).
	GenerateName string `json:"generateName,omitempty"`

	// Namespace defines the space within which name must be unique. An empty namespace is
	// equivalent to the "default" namespace, but "default" is the canonical representation.
	// Not all objects are required to be scoped to a namespace - the value of this field for
	// those objects will be empty.
	Namespace string `json:"namespace,omitempty"`

	// SelfLink is a URL representing this object.
	SelfLink string `json:"selfLink,omitempty"`

	// UID is the unique in time and space value for this object. It is typically generated by
	// the server on successful creation of a resource and is not allowed to change on PUT
	// operations.
	UID types.UID `json:"uid,omitempty"`

	// An opaque value that represents the version of this resource. May be used for optimistic
	// concurrency, change detection, and the watch operation on a resource or set of resources.
	// Clients must treat these values as opaque and values may only be valid for a particular
	// resource or set of resources. Only servers will generate resource versions.
	ResourceVersion string `json:"resourceVersion,omitempty"`

	// A sequence number representing a specific generation of the desired state.
	// Populated by the system. Read-only.
	Generation int64 `json:"generation,omitempty"`

	// CreationTimestamp is a timestamp representing the server time when this object was
	// created. It is not guaranteed to be set in happens-before order across separate operations.
	// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	CreationTimestamp unversioned.Time `json:"creationTimestamp,omitempty"`

	// DeletionTimestamp is the time after which this resource will be deleted. This
	// field is set by the server when a graceful deletion is requested by the user, and is not
	// directly settable by a client. The resource will be deleted (no longer visible from
	// resource lists, and not reachable by name) after the time in this field. Once set, this
	// value may not be unset or be set further into the future, although it may be shortened
	// or the resource may be deleted prior to this time. For example, a user may request that
	// a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination
	// signal to the containers in the pod. Once the resource is deleted in the API, the Kubelet
	// will send a hard termination signal to the container.
	DeletionTimestamp *unversioned.Time `json:"deletionTimestamp,omitempty"`

	// DeletionGracePeriodSeconds records the graceful deletion value set when graceful deletion
	// was requested. Represents the most recent grace period, and may only be shortened once set.
	DeletionGracePeriodSeconds *int64 `json:"deletionGracePeriodSeconds,omitempty"`

	// Labels are key value pairs that may be used to scope and select individual resources.
	// Label keys are of the form:
	//     label-key ::= prefixed-name | name
	//     prefixed-name ::= prefix '/' name
	//     prefix ::= DNS_SUBDOMAIN
	//     name ::= DNS_LABEL
	// The prefix is optional.  If the prefix is not specified, the key is assumed to be private
	// to the user.  Other system components that wish to use labels must specify a prefix.  The
	// "kubernetes.io/" prefix is reserved for use by kubernetes components.
	Labels map[string]string `json:"labels,omitempty"`

	// Annotations are unstructured key value data stored with a resource that may be set by
	// external tooling. They are not queryable and should be preserved when modifying
	// objects.  Annotation keys have the same formatting restrictions as Label keys. See the
	// comments on Labels for details.
	Annotations map[string]string `json:"annotations,omitempty"`

	// List of objects depended by this object. If ALL objects in the list have
	// been deleted, this object will be garbage collected. If this object is managed by a controller,
	// then an entry in this list will point to this controller, with the controller field set to true.
	// There cannot be more than one managing controller.
	OwnerReferences []OwnerReference `json:"ownerReferences,omitempty"`

	// Must be empty before the object is deleted from the registry. Each entry
	// is an identifier for the responsible component that will remove the entry
	// from the list. If the deletionTimestamp of the object is non-nil, entries
	// in this list can only be removed.
	Finalizers []string `json:"finalizers,omitempty"`

	// The name of the cluster which the object belongs to.
	// This is used to distinguish resources with same name and namespace in different clusters.
	// This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
	ClusterName string `json:"clusterName,omitempty"`
}

// OwnerReference contains enough information to let you identify an owning
// object. Currently, an owning object must be in the same namespace, so there
// is no namespace field.
type OwnerReference struct {
	// API version of the referent.
	APIVersion string `json:"apiVersion"`
	// Kind of the referent.
	// More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#types-kinds
	Kind string `json:"kind"`
	// Name of the referent.
	// More info: http://releases.k8s.io/HEAD/docs/user-guide/identifiers.md#names
	Name string `json:"name"`
	// UID of the referent.
	// More info: http://releases.k8s.io/HEAD/docs/user-guide/identifiers.md#uids
	UID types.UID `json:"uid"`
	// If true, this reference points to the managing controller.
	Controller *bool `json:"controller,omitempty"`
}

// NamespaceSpec describes the attributes on a Namespace
type NamespaceSpec struct {
	// Finalizers is an opaque list of values that must be empty to permanently remove object from storage
	Finalizers []FinalizerName
}

type FinalizerName string

// These are internal finalizer values to Kubernetes, must be qualified name unless defined here
const (
	FinalizerKubernetes FinalizerName = "kubernetes"
	FinalizerOrphan     string        = "orphan"
)

// NamespaceStatus is information about the current status of a Namespace.
type NamespaceStatus struct {
	// Phase is the current lifecycle phase of the namespace.
	Phase NamespacePhase `json:"phase,omitempty"`
}

type NamespacePhase string

// These are the valid phases of a namespace.
const (
	// NamespaceActive means the namespace is available for use in the system
	NamespaceActive NamespacePhase = "Active"
	// NamespaceTerminating means the namespace is undergoing graceful termination
	NamespaceTerminating NamespacePhase = "Terminating"
)

// A namespace provides a scope for Names.
// Use of multiple namespaces is optional
type Namespace struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	// Spec defines the behavior of the Namespace.
	Spec NamespaceSpec `json:"spec,omitempty"`

	// Status describes the current status of a Namespace
	Status NamespaceStatus `json:"status,omitempty"`
}

// NamespaceList is a list of Namespaces.
type NamespaceList struct {
	unversioned.TypeMeta `json:",inline"`
	unversioned.ListMeta `json:"metadata,omitempty"`

	Items []Namespace `json:"items"`
}

const (
	// NamespaceDefault means the object is in the default namespace which is applied when not specified by clients
	NamespaceDefault string = "default"
	// NamespaceAll is the default argument to specify on a context when you want to list or filter resources across all namespaces
	NamespaceAll string = ""
	// NamespaceNone is the argument for a context when there is no namespace.
	NamespaceNone string = ""
	// NamespaceSystem is the system namespace where we place system components.
	NamespaceSystem string = "kube-system"
	// TerminationMessagePathDefault means the default path to capture the application termination message running in a container
	TerminationMessagePathDefault string = "/dev/termination-log"
)

// Similarly to above, these are constants to support HTTP PATCH utilized by
// both the client and server that didn't make sense for a whole package to be
// dedicated to.
type PatchType string

const (
	JSONPatchType           PatchType = "application/json-patch+json"
	MergePatchType          PatchType = "application/merge-patch+json"
	StrategicMergePatchType PatchType = "application/strategic-merge-patch+json"
)

// Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
type Preconditions struct {
	// Specifies the target UID.
	UID *types.UID `json:"uid,omitempty"`
}

// DeleteOptions may be provided when deleting an API object
type DeleteOptions struct {
	unversioned.TypeMeta `json:",inline"`

	// Optional duration in seconds before the object should be deleted. Value must be non-negative integer.
	// The value zero indicates delete immediately. If this value is nil, the default grace period for the
	// specified type will be used.
	GracePeriodSeconds *int64 `json:"gracePeriodSeconds,omitempty"`

	// Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
	// returned.
	Preconditions *Preconditions `json:"preconditions,omitempty"`

	// Should the dependent objects be orphaned. If true/false, the "orphan"
	// finalizer will be added to/removed from the object's finalizers list.
	OrphanDependents *bool `json:"orphanDependents,omitempty"`
}

// ExportOptions is the query options to the standard REST get call.
type ExportOptions struct {
	unversioned.TypeMeta `json:",inline"`
	// Should this value be exported.  Export strips fields that a user can not specify.
	Export bool `json:"export"`
	// Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
	Exact bool `json:"exact"`
}

// ListOptions is the query options to a standard REST list call, and has future support for
// watch calls.
type ListOptions struct {
	unversioned.TypeMeta `json:",inline"`

	// A selector based on labels
	LabelSelector labels.Selector
	// A selector based on fields
	FieldSelector fields.Selector
	//If true, watch for changes to this list
	Watch bool
	// For watch, it's the resource version to watch.
	// For list,
	// - if unset, then the result is returned from remote storage based on quorum-read flag;
	// - if it's 0, then we simply return what we currently have in cache, no guarantee;
	// - if set to non zero, then the result is as fresh as given rv.
	ResourceVersion string
	// Timeout for the list/watch call.
	TimeoutSeconds *int64
}

type LoginSpec struct {
	AuthName string `json:"authname,omitempty"`
	Auth     string `json:"auth,omitempty"`
	AuthID   string `json:"authID,omitempty"`
	Token    string `json:"token,omitempty"`
}

type Login struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec LoginSpec `json:"spec,omitempty"`
}

type LoginList struct {
	unversioned.TypeMeta `json:",inline"`
	unversioned.ListMeta `json:"metadata,omitempty"`

	Items []Login `json:"items"`
}

//User is a mysql users map
type UserTokenSpec struct {
	ID         int64            `json:"id,omitempty" freezer:"column:id" gorm:"column:id"`
	Token      string           `json:"token,omitempty" freezer:"column:token" gorm:"column:token"`
	UserID     int64            `json:"userID,omitempty" freezer:"column:user_id" gorm:"column:user_id"`
	CreateTime unversioned.Time `json:"createTime,omitempty" freezer:"column:create_time" gorm:"column:create_time"`
	ExpireTime unversioned.Time `json:"expireTime,omitempty" freezer:"column:expire_time" gorm:"column:expire_time"`
	Name       string           `json:"name,omitempty" freezer:"column:name;resoucekey" gorm:"column:name"`
}

type UserToken struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec UserTokenSpec `json:"spec,omitempty"`
}

type UserTokenList struct {
	unversioned.TypeMeta `json:",inline"`
	unversioned.ListMeta `json:"metadata,omitempty"`

	Items []UserToken `json:"items"`
}

type VultrServerInfo struct {
	CreatedTime string `json:"createdTime,omitempty"`
	Location    string `json:"location,omitempty"`
	Name        string `json:"name,omitempty"`
	Status      string `json:"status,omitempty"`

	IPV4Addr    string `json:"ipv4Addr,omitempty"`
	IPV4NetMask string `json:"ipv4NetMask,omitempty"`
	IPV4Gateway string `json:"ipv4Gateway,omitempty"`

	PendingCharges float64 `json:"pendingCharges,omitempty"`
}

type DGServerInfo struct {
	Location    string `json:"location,omitempty"`
	Name        string `json:"name,omitempty"`
	Status      string `json:"status,omitempty"`
	CreatedTime string `json:"createdTime,omitempty"`

	IPV4Addr    string `json:"ipv4Addr,omitempty"`
	IPV4NetMask string `json:"ipv4NetMask,omitempty"`
	IPV4Gateway string `json:"ipv4Gateway,omitempty"`
}

type AccServerSpec struct {
	ID       string `json:"id,omitempty"`
	Size     string `json:"size,omitempty"`
	Region   string `json:"region,omitempty"`
	Image    string `json:"image,omitempty"`
	SSHKeyID string `json:"sshKeyID,omitempty"`
	Name     string `json:"name,omitempty"`

	AccName string `json:"accName,omitempty"`

	DigitalOcean DGServerInfo    `json:"digitalocean,omitempty"`
	Vultr        VultrServerInfo `json:"vultr,omitempty"`
}

type AccServer struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec AccServerSpec `json:"spec,omitempty"`
}

type AccServerList struct {
	unversioned.TypeMeta `json:",inline"`
	unversioned.ListMeta `json:"metadata,omitempty"`

	Items []AccServer `json:"items"`
}

const (
	CNISPCMCC    = "cnISPCMCC"
	CNISPUNICOM  = "cnISPUnicom"
	CNISPASPCTCC = "cnISPCTCC"
	CNISPOther   = "cnISPOther"
)

const (
	NodeUserSpaceDefault = "default"
	NodeUserSpaceAPI     = "api"
	NodeUserSpaceDev     = "develop"
)

const (
	NodeLablesChinaISP    = "cnISP"
	NodeLablesUserSpace   = "userSpace"
	NodeLablesVPSLocation = "vpsLocation"
	NodeLablesVPSID       = "vpsID"
	NodeLablesVPSOP       = "vpsOperator"
	NodeLablesVPSName     = "vpsName"
	NodeLablesVPSIP       = "vpsIP"
)

type AccServerDeploySS struct {
	HostList  []string          `json:"hostList,omitempty"`
	Attribute map[string]string `json:"attr,omitempty"`
}

type AccExecSpec struct {
	SSHKey  string            `json:"sshKey,omitempty"`
	Command string            `json:"command,omitempty"`
	ID      int64             `json:"id,omitempty"`
	Deploy  AccServerDeploySS `json:"deploySS,omitempty"`
	AccName string            `json:"accName,omitempty"`
}

type AccExec struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec AccExecSpec `json:"spec,omitempty"`
}

type SSHKey struct {
	KeyID       string `json:"keyID,omitempty"`
	Name        string `json:"name,omitempty"`
	Key         string `json:"key,omitempty"`
	FingerPrint string `json:"fingerprint,omitempty"`
}

type AccSSHKeySpec struct {
	Keys    []SSHKey `json:"keys,omitempty"`
	AccName string   `json:"accName,omitempty"`
}

type AccSSHKey struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec AccSSHKeySpec `json:"spec,omitempty"`
}

// type AccSSHKeyList struct {
// 	unversioned.TypeMeta `json:",inline"`
// 	unversioned.ListMeta `json:"metadata,omitempty"`
//
// 	Items []AccSSHKey `json:"items"`
// }

type VultrAccountInfo struct {
	Balance           float64 `json:"balance,omitempty"`
	PendingCharges    float64 `json:"pendingCharges,omitempty"`
	LastPaymentDate   string  `json:"lastPaymentDate,omitempty"`
	LastPaymentAmount float64 `json:"lastPaymentAmount,omitempty"`
}

type DGAccountInfo struct {
	DropletLimit  int    `json:"dropletLimit,omitempty"`
	Email         string `json:"email,omitempty"`
	UUID          string `json:"uuid,omitempty"`
	EmailVerified bool   `json:"emailVerified,omitempty"`
}

type AccountInfoSpec struct {
	DigitalOcean DGAccountInfo    `json:"digitalocean,omitempty"`
	Vultr        VultrAccountInfo `json:"vultr,omitempty"`
	AccName      string           `json:"accName,omitempty"`
}

type AccountInfo struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec AccountInfoSpec `json:"spec,omitempty"`
}

const (
	OperatorVultr        = "Vultr"
	OperatorDigitalOcean = "DigitalOcean"
)

type OperatorType string

type AccountDetail struct {
	ID             int64            `json:"-" column:"id"`
	Name           string           `json:"name,omitempty" column:"name"`
	Operators      string           `json:"operators,omitempty" column:"operators"`
	Key            string           `json:"key,omitempty" column:"api_key" gorm:"column:api_key"`
	Descryption    string           `json:"descryption,omitempty" column:"descryption"`
	CreditCeilings float64          `json:"creditCeilings,omitempty" column:"credit_ceilings"`
	Lables         string           `json:"lables,omitempty" column:"lables"`
	CreateTime     unversioned.Time `json:"creationTime,omitempty" column:"expire_time" gorm:"column:expire_time"`
	ExpireTime     unversioned.Time `json:"expire,omitempty" column:"created_time" gorm:"column:created_time"`
}

// AccountSpec of Vultr account
type AccountSpec struct {
	AccDetail AccountDetail `json:"account,omitempty"`
}

type Account struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec AccountSpec `json:"spec,omitempty"`
}

type AccountList struct {
	unversioned.TypeMeta `json:",inline"`
	unversioned.ListMeta `json:"metadata,omitempty"`

	Items []Account `json:"items"`
}

type UserReferences struct {
	ID              int64  `json:"id,omitempty"`
	Name            string `json:"name,omitempty"`
	Port            int64  `json:"port,omitempty"`
	Method          string `json:"method,omitempty"`
	Password        string `json:"password,omitempty"`
	EnableOTA       bool   `json:"enableOTA, omitempty"`
	UploadTraffic   int64  `json:"uploadTraffic,omitempty"`   //upload traffic for per user
	DownloadTraffic int64  `json:"downloadTraffic,omitempty"` //download traffic for per user
}

const (
	NodeUserPhaseAdd    = "add"
	NodeUserPhaseDelete = "del"
	NodeUserPhaseUpdate = "update"
)

type NodeUserPhase string

type NodeUserSpec struct {
	User     UserReferences `json:"user,omitempty"`
	NodeName string         `json:"nodeName,omitempty"`
	Phase    NodeUserPhase  `json:"phase,omitempty"`
}

//put your user into your node with node name
//like as /api/node/{nodename}/nodeuser/{username}
type NodeUser struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec NodeUserSpec `json:"spec,omitempty"`
}

type NodeUserList struct {
	unversioned.TypeMeta `json:",inline"`
	unversioned.ListMeta `json:"metadata,omitempty"`

	Items []NodeUser `json:"items,omitempty"`
}

const (
	NodeAnnotationUserCnt    = "userCount"
	NodeAnnotationRefreshCnt = "Refresh"
	NodeAnnotationVersion    = "version"
)

type NodeServer struct {
	ID                   int64  `json:"id" freezer:"column:id" gorm:"column:id"`
	Name                 string `json:"name,omitempty" freezer:"column:name;resoucekey" gorm:"column:name"`
	EnableOTA            bool   `json:"enableOTA" freezer:"column:enableota" gorm:"column:enableota"`
	Host                 string `json:"host,omitempty" freezer:"column:server" gorm:"column:server"`
	Method               string `json:"method" freezer:"column:method" gorm:"column:method"`
	Status               int64  `json:"status,omitempty" freezer:"column:status" gorm:"column:status"`
	Location             string `json:"location,omitempty" freezer:"column:location" gorm:"column:location"`
	AccServerID          int64  `json:"accServerID,omitempty" freezer:"column:vps_server_id" gorm:"column:vps_server_id"`
	AccServerName        string `json:"accServerName,omitempty" freezer:"column:vps_server_name" gorm:"column:vps_server_name"`
	Description          string `json:"description,omitempty" freezer:"column:description" gorm:"column:description"`
	TrafficLimit         int64  `json:"trafficLimit,omitempty" freezer:"column:traffic_limit" gorm:"column:traffic_limit"`
	Upload               int64  `json:"upload,omitempty" freezer:"column:upload" gorm:"column:upload"`
	Download             int64  `json:"download,omitempty" freezer:"column:download" gorm:"column:download"`
	TrafficRate          int64  `json:"trafficRate,omitempty" freezer:"column:traffic_rate" gorm:"column:traffic_rate"`
	TotalUploadTraffic   int64  `json:"totalUploadTraffic,omitempty" freezer:"column:total_upload" gorm:"column:total_upload"`
	TotalDownloadTraffic int64  `json:"totalDownloadTraffic,omitempty" freezer:"column:total_download" gorm:"column:total_download"`
	CustomMethod         int    `json:"customMethod,omitempty" freezer:"column:custom_method" gorm:"column:custom_method"`
}

type NodeSpec struct {
	Server NodeServer          `json:"server,omitempty" freezer:"table:ss_node"`
	Users  map[string]NodeUser `json:"users,omitempty"`
}

type Node struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec NodeSpec `json:"spec,omitempty"`
}

type NodeList struct {
	unversioned.TypeMeta `json:",inline"`
	unversioned.ListMeta `json:"metadata,omitempty"`

	Items []Node `json:"items"`
}

type APIServerInfor struct {
	ID         int64     `json:"id, omitempty" column:"id"`
	Name       string    `json:"name, omitempty" column:"name"`
	Host       string    `json:"host, omitempty" column:"host"`
	Port       int64     `json:"port, omitempty" column:"port"`
	Status     bool      `json:"status, omitempty" column:"status"`
	CreateTime time.Time `json:"creationTime,omitempty" column:"created_time" gorm:"column:created_time"`
}

type APIServerSpec struct {
	Server   APIServerInfor `json:"server, omitempty"`
	HostList []string       `json:"hosts, omitempty"`
}

type APIServer struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec APIServerSpec `json:"spec,omitempty"`
}

type APIServerList struct {
	unversioned.TypeMeta `json:",inline"`
	unversioned.ListMeta `json:"metadata,omitempty"`

	Items []APIServer `json:"items"`
}

type NodeReferences struct {
	Host string         `json:"host,omitempty"`
	User UserReferences `json:"user,omitempty"`
}

const (
	UserServicetDefaultNode = "default"
)

type UserServiceSpec struct {
	Nodes   map[string]NodeReferences `json:"nodes,omitempty"`
	NodeCnt uint                      `json:"nodecnt,omitempty"`
	Status  bool                      `json:"status,omitempty"`
}

type UserService struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec UserServiceSpec `json:"spec,omitempty"`
}

type UserServiceList struct {
	unversioned.TypeMeta `json:",inline"`
	unversioned.ListMeta `json:"metadata,omitempty"`

	Items []UserService `json:"items"`
}

type UserInfo struct {
	ID                   int64            `json:"id,omitempty" freezer:"column:id"`
	Passwd               string           `json:"passwd,omitempty" freezer:"column:passwd"`
	Email                string           `json:"email,omitempty" freezer:"column:email"`
	EnableOTA            bool             `json:"enableOTA,omitempty" freezer:"column:enable_ota"`
	TrafficLimit         int64            `json:"trafficLimit,omitempty" freezer:"column:traffic_limit" gorm:"column:traffic_limit"` //traffic for per user
	UploadTraffic        int64            `json:"uploadTraffic,omitempty" freezer:"column:upload" gorm:"column:upload"`              //upload traffic for per user
	DownloadTraffic      int64            `json:"downloadTraffic,omitempty" freezer:"column:download" gorm:"column:download"`        //download traffic for per user
	Name                 string           `json:"name,omitempty" freezer:"column:user_name;resoucekey" gorm:"column:user_name"`
	ManagePasswd         string           `json:"managePasswd,omitempty" freezer:"column:manage_pass" gorm:"column:manage_pass"`
	ExpireTime           unversioned.Time `json:"expireTime,omitempty" freezer:"column:expire_time" gorm:"column:expire_time"`
	EmailVerify          int16            `json:"emailVerify,omitempty" freezer:"column:is_email_verify" gorm:"column:is_email_verify"`
	RegIPAddr            string           `json:"regIPAddr,omitempty" freezer:"column:reg_ip" gorm:"column:reg_ip"`
	RegDBTime            unversioned.Time `json:"regTime,omitempty" freezer:"column:reg_date" gorm:"column:reg_date"`
	Description          string           `json:"description,omitempty" freezer:"column:description" gorm:"column:description"`
	TrafficRate          float64          `json:"trafficRate,omitempty" freezer:"column:traffic_rate" gorm:"column:traffic_rate"`
	IsAdmin              int64            `json:"isAdmin,omitempty" freezer:"column:is_admin" gorm:"column:is_admin"`
	LastCheckInTime      unversioned.Time `json:"-" freezer:"column:last_check_in_time" gorm:"column:last_check_in_time"`
	LastResetPwdTime     unversioned.Time `json:"-" freezer:"column:last_reset_pass_time" gorm:"column:last_reset_pass_time"`
	TotalUploadTraffic   int64            `json:"totalUploadTraffic,omitempty" freezer:"column:total_upload" gorm:"column:total_upload"`
	TotalDownloadTraffic int64            `json:"totalDownloadTraffic,omitempty" freezer:"column:total_download" gorm:"column:total_download"`
	Status               int64            `json:"status,omitempty" freezer:"column:status" gorm:"column:status"`
}

type UserSpec struct {
	DetailInfo UserInfo `json:"detailInfo,omitempty" freezer:"table:user"`
}

type User struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec UserSpec `json:"spec,omitempty"`
}

type UserList struct {
	unversioned.TypeMeta `json:",inline"`
	unversioned.ListMeta `json:"metadata,omitempty"`

	Items []User `json:"spec,omitempty"`
}

type UserPublicFileSpec struct {
	FileName    string `json:"file,omitempty"`
	Description string `json:"description,omitempty"`
}

type UserPublicFile struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec UserPublicFileSpec `json:"spec,omitempty"`
}

type UserPublicFileList struct {
	unversioned.TypeMeta `json:",inline"`
	unversioned.ListMeta `json:"metadata,omitempty"`

	Items []UserPublicFile `json:"items,omitempty"`
}

type ActiveAPINodeSpec struct {
	Host     string `json:"host,omitempty"`
	Port     int    `json:"port,omitempty"`
	Password string `jsong:"pwd,omitempty"`
	Method   string `json:"method,omitempty"`
}

type ActiveAPINode struct {
	unversioned.TypeMeta `json:",inline"`
	ObjectMeta           `json:"metadata,omitempty"`

	Spec ActiveAPINodeSpec `json:"spec,omitempty"`
}

type ActiveAPINodeList struct {
	unversioned.TypeMeta `json:",inline"`
	unversioned.ListMeta `json:"metadata,omitempty"`

	Items       []ActiveAPINode `json:"items,omitempty"`
	EncryptData string          `json:"encData,omitempty"`
}
